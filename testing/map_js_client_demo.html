<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Client - 修复：Prediction + Reconciliation + Hermite</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #111;
            color: #ddd;
            font-family: monospace;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #1b1b1b;
        }

        #ui {
            position: fixed;
            left: 8px;
            top: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 6px;
        }

        .small {
            font-size: 12px;
            color: #9aa;
        }
    </style>
</head>

<body>
    <div id="ui">
        状态: <span id="status">init</span><br />
        <div class="small" id="dbg"></div>
        WASD 控制移动 · 本地预测 + 修正 · Hermite 插值 · 外推保护
    </div>
    <canvas id="game"></canvas>

    <script>
        /* ---------- 配置 ---------- */
        const WS_URL = 'ws://www.mfavant.xyz:20029'; // 你的服务器
        const PLAYER_RADIUS = 12;
        const PLAYER_SPEED = 200;
        const CLIENT_SEND_RATE = 10; // 每秒发包次数
        const INTERP_DELAY = 0.12; // 插值延迟 (秒)
        const EXTRAPOLATION_LIMIT = 0.4; // 外推最大秒数
        const LOCAL_COLLISION = true;

        /* ---------- 画布 ---------- */
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
        addEventListener('resize', resize); resize();

        /* ---------- 网络与时钟同步 ---------- */
        let ws = null;
        let clientId = null;

        const rttSamples = [];      // ms
        const offsetSamples = [];   // serverTime - (clientTime + rtt/2)
        let serverOffset = 0; // serverTime - localTime（近似）
        function nowLocalMs() { return Date.now(); }
        function nowServerMs() { return Date.now() + serverOffset; }

        function median(arr) {
            if (!arr.length) return 0;
            const a = arr.slice().sort((x, y) => x - y);
            return a[Math.floor(a.length / 2)];
        }

        function connect() {
            ws = new WebSocket(WS_URL);
            ws.onopen = () => { setStatus('connected'); startTimeSync(); };
            ws.onclose = () => { setStatus('disconnected'); setTimeout(connect, 1000); };
            ws.onerror = e => console.warn('ws err', e);
            ws.onmessage = ev => {
                let msg;
                try { msg = JSON.parse(ev.data); } catch (e) { return; }
                handleServerMsg(msg);
            };
        }
        connect();

        function startTimeSync() {
            rttSamples.length = 0;
            offsetSamples.length = 0;
            const tries = 6;
            let i = 0;
            function sample() {
                const t0 = nowLocalMs();
                try { ws.send(JSON.stringify({ type: 'ping', clientTime: t0 })); } catch (e) { }
                i++;
                if (i < tries) setTimeout(sample, 120);
                else {
                    if (offsetSamples.length) {
                        serverOffset = median(offsetSamples);
                    }
                }
            }
            sample();
        }

        /* ---------- 输入 ---------- */
        let inputDir = { x: 0, y: 0 };
        const pressed = {};
        addEventListener('keydown', e => { pressed[e.key.toLowerCase()] = true; updateInput(); });
        addEventListener('keyup', e => { pressed[e.key.toLowerCase()] = false; updateInput(); });

        function updateInput() {
            let dx = 0, dy = 0;
            if (pressed['w']) dy -= 1;
            if (pressed['s']) dy += 1;
            if (pressed['a']) dx -= 1;
            if (pressed['d']) dx += 1;
            if (dx !== 0 || dy !== 0) {
                const len = Math.hypot(dx, dy) || 1;
                dx /= len; dy /= len;
            }
            inputDir.x = dx; inputDir.y = dy;
        }

        /* ---------- 输入发送与历史 ---------- */
        let seq = 0;
        const inputHistory = []; // { seq, dirX, dirY, clientTime }

        setInterval(() => {
            if (!ws || ws.readyState !== 1) return;
            seq++;
            const clientTime = nowLocalMs();
            const msg = {
                type: 'input', seq,
                dirX: inputDir.x, dirY: inputDir.y,
                clientTime
            };
            try { ws.send(JSON.stringify(msg)); } catch (e) { }
            inputHistory.push(msg);
            if (inputHistory.length > 300) inputHistory.shift();
        }, 1000 / CLIENT_SEND_RATE);

        /* ---------- 本地预测（可被修正） ---------- */
        let myPos = { x: 400, y: 300 };
        let myVel = { x: 0, y: 0 };

        // 平滑修正参数（当收到服务器权威位置时使用）
        // 使用更稳健的结构：{ startDx, startDy, totalMs, remainingMs }
        let correction = { startDx: 0, startDy: 0, totalMs: 0, remainingMs: 0 };

        /* ---------- 状态缓存（服务器数据） ---------- */
        const buffers = new Map(); // id -> [{ t(server ms), x, y, vx, vy }]

        /* ---------- 服务器消息处理 ---------- */
        function handleServerMsg(msg) {
            if (msg.type === 'init') {
                clientId = String(msg.id);
                myPos.x = msg.x; myPos.y = msg.y;
                buffers.set(clientId, []);
                startTimeSync();
            } else if (msg.type === 'pong') {
                const t1 = nowLocalMs();
                const rtt = t1 - msg.clientTime;
                rttSamples.push(rtt);
                if (rttSamples.length > 50) rttSamples.shift();

                const offset = msg.serverTime - (msg.clientTime + rtt / 2);
                offsetSamples.push(offset);
                if (offsetSamples.length > 50) offsetSamples.shift();

                serverOffset = median(offsetSamples);
            } else if (msg.type === 'state') {
                const sTime = msg.serverTime || nowServerMs();
                for (const p of msg.players) {
                    const id = String(p.id);
                    if (!buffers.has(id)) buffers.set(id, []);
                    const buf = buffers.get(id);
                    buf.push({ t: sTime, x: p.x, y: p.y, vx: p.vx, vy: p.vy, raw: p });
                    if (buf.length > 60) buf.shift();

                    // 如果这是我的权威状态，执行 reconciliation（修正）
                    if (id === clientId) {
                        reconcileLocalWithServer(p, sTime);
                    }
                }
            }
        }

        /* ---------- Reconciliation（本地纠偏） ---------- */
        function getEstimatedRtt() {
            if (!rttSamples.length) return 200; // 保守默认 200ms
            return median(rttSamples);
        }

        function reconcileLocalWithServer(serverP, serverTimeMs) {
            // 1) 估算 RTT/one-way
            const rtt = getEstimatedRtt();
            const approxOneWay = rtt / 2; // ms
            // cutoff：客户端时间 <= cutoff 被认为服务器已包含
            const cutoffClientTime = serverTimeMs - approxOneWay;

            // 收集未被确认（可能未被服务器应用）的输入
            const unconfirmed = inputHistory.filter(it => it.clientTime > cutoffClientTime);

            // 2) 计算重放后的理想位置（replayPos），但不要立即替换 myPos
            let replayX = serverP.x;
            let replayY = serverP.y;

            // 使用每个输入发送间隔作为步长进行粗略重放（这是简单且稳健的做法）
            // 但我们不会把 replay 直接应用到 myPos，而是用于决定是否需要平滑修正
            const stepSec = 1 / CLIENT_SEND_RATE;
            for (const it of unconfirmed) {
                replayX += it.dirX * PLAYER_SPEED * stepSec;
                replayY += it.dirY * PLAYER_SPEED * stepSec;
            }

            // 3) 计算偏差并决定如何修正（直接修或平滑）
            const dx = replayX - myPos.x;
            const dy = replayY - myPos.y;
            const dist2 = dx * dx + dy * dy;

            const VERY_SMALL2 = 0.5 * 0.5;
            if (dist2 < VERY_SMALL2) {
                // 微小偏差：直接设为重放位置（避免长时间漂移）
                myPos.x = replayX;
                myPos.y = replayY;
                // 也同步速度为服务器给的速度（减少短期外推误差）
                myVel.x = serverP.vx || 0;
                myVel.y = serverP.vy || 0;
                correction.startDx = correction.startDy = correction.totalMs = correction.remainingMs = 0;
            } else {
                // 偏差较大：设置平滑修正（线性衰减）
                const SMOOTH_MS = 120; // 平滑时间，可调整
                correction.startDx = dx;
                correction.startDy = dy;
                correction.totalMs = SMOOTH_MS;
                correction.remainingMs = SMOOTH_MS;

                // 同步速度基于服务器（可减少外推偏差）
                myVel.x = serverP.vx || 0;
                myVel.y = serverP.vy || 0;
            }

            // 注意：不立即调用重放改变 myPos，这样主循环的本地预测不会和重放结果冲突。
            // 平滑修正会在后续帧里逐步把 myPos 带到 replayPos。
        }

        /* ---------- Hermite 插值（用于其他玩家） ---------- */
        function hermiteInterpolate(p0, p1, t) {
            const t2 = t * t, t3 = t2 * t;
            const h00 = 2 * t3 - 3 * t2 + 1;
            const h10 = t3 - 2 * t2 + t;
            const h01 = -2 * t3 + 3 * t2;
            const h11 = t3 - t2;
            const dt = (p1.t - p0.t) / 1000 || 0.001; // 秒，避免 0 导致问题
            const vx0 = p0.vx || 0;
            const vx1 = p1.vx || 0;
            const vy0 = p0.vy || 0;
            const vy1 = p1.vy || 0;
            return {
                x: h00 * p0.x + h10 * vx0 * dt + h01 * p1.x + h11 * vx1 * dt,
                y: h00 * p0.y + h10 * vy0 * dt + h01 * p1.y + h11 * vy1 * dt
            };
        }

        function samplePositionAt(id, renderTimeMs) {
            const buf = buffers.get(id);
            if (!buf || !buf.length) return null;

            if (buf.length === 1) return { x: buf[0].x, y: buf[0].y };

            // 在 buf 中寻找包含 renderTime 的段
            let L = -1;
            for (let i = 0; i < buf.length - 1; i++) {
                if (buf[i].t <= renderTimeMs && buf[i + 1].t >= renderTimeMs) {
                    L = i;
                    break;
                }
            }

            if (L >= 0) {
                const p0 = buf[L], p1 = buf[L + 1];
                const denom = (p1.t - p0.t) || 1;
                const t = (renderTimeMs - p0.t) / denom;
                return hermiteInterpolate(p0, p1, Math.max(0, Math.min(1, t)));
            }

            // 请求时间早于记录的最早时间：返回最早位置
            if (renderTimeMs < buf[0].t) return { x: buf[0].x, y: buf[0].y };

            // 否则使用线性外推（基于最后的速度）
            const last = buf[buf.length - 1];
            const dt = (renderTimeMs - last.t) / 1000;
            if (dt > EXTRAPOLATION_LIMIT) return { x: last.x, y: last.y };
            return { x: last.x + (last.vx || 0) * dt, y: last.y + (last.vy || 0) * dt };
        }

        /* ---------- 主循环 ---------- */
        let last = performance.now();
        requestAnimationFrame(function loop(now) {
            const dt = Math.min(0.05, (now - last) / 1000);
            last = now;

            // 本地预测：即时响应键盘
            myPos.x += inputDir.x * PLAYER_SPEED * dt;
            myPos.y += inputDir.y * PLAYER_SPEED * dt;

            // 应用平滑 correction（如果存在）
            if (correction.remainingMs > 0 && correction.totalMs > 0) {
                const applyMs = Math.min(correction.remainingMs, dt * 1000);
                // 按照 totalMs 的比例应用：每帧应用 startDx * (applyMs / totalMs)
                const frac = applyMs / correction.totalMs;
                const applyX = correction.startDx * frac;
                const applyY = correction.startDy * frac;
                myPos.x += applyX;
                myPos.y += applyY;

                // 减少未应用的部分
                correction.startDx -= applyX;
                correction.startDy -= applyY;
                correction.remainingMs -= applyMs;
                if (correction.remainingMs <= 0) {
                    correction.startDx = 0; correction.startDy = 0;
                    correction.totalMs = 0; correction.remainingMs = 0;
                }
            }

            // 绘制
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const camX = myPos.x;
            const camY = myPos.y;

            drawGridWithCoords(camX, camY);

            // renderTime：服务器时间偏移减去插值延迟（以 ms 表示）
            const renderTime = nowServerMs() - INTERP_DELAY * 1000;

            // 绘制其他玩家
            for (const [id] of buffers) {
                if (id === clientId) continue;
                const p = samplePositionAt(id, renderTime);
                if (!p) continue;

                const sx = p.x - camX + canvas.width / 2;
                const sy = p.y - camY + canvas.height / 2;

                ctx.fillStyle = "#ff6666";
                ctx.beginPath();
                ctx.arc(sx, sy, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // 绘制自己（使用修正后的 myPos）
            ctx.fillStyle = "#00ff88";
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 10, 0, Math.PI * 2);
            ctx.fill();

            // 调试信息
            document.getElementById("dbg").innerText =
                `id:${clientId}  offset:${Math.round(serverOffset)}ms  rtt:${Math.round(getEstimatedRtt())}ms  buffers:${buffers.size}`;

            requestAnimationFrame(loop);
        });

        /* ---------------------------------------------
         * 网格 + 世界坐标标注（和你原来的一样）
         * ------------------------------------------- */
        function drawGridWithCoords(cx, cy) {
            const g = 50;
            const w = canvas.width, h = canvas.height;

            const offsetX = cx - w / 2;
            const offsetY = cy - h / 2;

            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.font = "8px monospace";
            ctx.fillStyle = "#555";

            const startX = Math.floor(offsetX / g) * g;
            const startY = Math.floor(offsetY / g) * g;

            for (let x = startX; x <= offsetX + w; x += g) {
                const sx = x - offsetX;
                ctx.beginPath();
                ctx.moveTo(sx + 0.5, 0);
                ctx.lineTo(sx + 0.5, h);
                ctx.stroke();
            }

            for (let y = startY; y <= offsetY + h; y += g) {
                const sy = y - offsetY;
                ctx.beginPath();
                ctx.moveTo(0, sy + 0.5);
                ctx.lineTo(w, sy + 0.5);
                ctx.stroke();
            }

            for (let x = startX; x <= offsetX + w; x += g) {
                for (let y = startY; y <= offsetY + h; y += g) {
                    const centerX = x + g / 2;
                    const centerY = y + g / 2;
                    const sx = centerX - offsetX;
                    const sy = centerY - offsetY;
                    ctx.fillText(`(${Math.round(centerX)},${Math.round(centerY)})`, sx - 20, sy + 3);
                }
            }
        }

        function setStatus(s) {
            document.getElementById("status").innerText = s;
        }

        window.reconnect = connect;
    </script>
</body>

</html>